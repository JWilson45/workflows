name: Reusable Build & Deploy

on:
  workflow_call:
    inputs:
      image_name:
        description: "Full image name (e.g. ghcr.io/org/repo)"
        required: true
        type: string
      app_dir:
        description: "Path to the app directory (contains package.json & Dockerfile)"
        required: true
        type: string
      dockerfile:
        description: "Path to Dockerfile (relative to repo root)"
        required: false
        default: "${{ inputs.app_dir }}/Dockerfile"
        type: string
      platforms:
        description: "Platforms to build (comma-separated)"
        required: false
        default: "linux/amd64"
        type: string
      kube_namespace:
        description: "Kubernetes namespace for deploy"
        required: false
        default: "default"
        type: string
      kube_deployment:
        description: "Kubernetes deployment name"
        required: true
        type: string
      kube_container:
        description: "Container name inside the deployment"
        required: true
        type: string
      do_deploy:
        description: "Whether to deploy after build (true/false)"
        required: false
        default: "true"
        type: string
      runner_label:
        description: "Runner label to use (e.g. ubuntu-latest, mm-runner-set)"
        required: false
        default: "ubuntu-latest"
        type: string
    secrets:
      kubeconfig_b64:
        description: "Base64-encoded kubeconfig"
        required: true

jobs:
  build-and-deploy:
    runs-on: ${{ inputs.runner_label }}
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: write
      id-token: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false

      - name: Extract version from package.json
        id: version
        run: |
          ver=$(jq -r '.version' "${{ inputs.app_dir }}/package.json")
          echo "version=$ver" >> "$GITHUB_OUTPUT"

      - name: Check if image version exists in GHCR
        id: image_exists
        run: |
          TAG="${{ steps.version.outputs.version }}"
          IMAGE_REF="${{ inputs.image_name }}"
          REGISTRY="$(echo $IMAGE_REF | cut -d'/' -f1)"
          REPO="$(echo $IMAGE_REF | cut -d'/' -f2-)"
          FULL_IMAGE="$IMAGE_REF:$TAG"
          TOKEN=$(curl -s "https://$REGISTRY/token?scope=repository:$REPO:pull" | jq -r .token)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.oci.image.index.v1+json" \
            "https://$REGISTRY/v2/$REPO/manifests/$TAG")
          echo "Got HTTP status: $STATUS"
          if [ "$STATUS" = "200" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Image $FULL_IMAGE already exists in GHCR. Skipping build and push." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Add skip message to workflow summary
        if: steps.image_exists.outputs.exists == 'true'
        run: |
          echo "### Skipped build & push: tag \`${{ steps.version.outputs.version }}\` already exists." >> $GITHUB_STEP_SUMMARY

      - name: Set up Docker Buildx
        if: steps.image_exists.outputs.exists == 'false'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: steps.image_exists.outputs.exists == 'false'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push multi-arch image
        if: steps.image_exists.outputs.exists == 'false'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ inputs.dockerfile }}
          platforms: ${{ inputs.platforms }}
          push: true
          provenance: mode=max
          sbom: true
          tags: |
            ${{ inputs.image_name }}:${{ steps.version.outputs.version }}
            ${{ inputs.image_name }}:latest

      - name: Attest image provenance (SLSA)
        if: steps.image_exists.outputs.exists == 'false'
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ inputs.image_name }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

      - name: Create GitHub Release via curl
        if: steps.image_exists.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          TAG="${{ steps.version.outputs.version }}"
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/repos/$OWNER/$REPO/releases" \
            -d "$(jq -n \
              --arg tag "$TAG" \
              --arg name "Release $TAG" \
              '{tag_name: $tag, name: $name, draft: false, prerelease: false, generate_release_notes: true}')" \
          | jq '.html_url'

      - name: Install kubectl and load kubeconfig
        if: ${{ inputs.do_deploy == 'true' && steps.image_exists.outputs.exists == 'false' }}
        uses: tale/kubectl-action@v1
        with:
          base64-kube-config: ${{ secrets.kubeconfig_b64 }}

      - name: Set image tag & apply
        if: ${{ inputs.do_deploy == 'true' && steps.image_exists.outputs.exists == 'false' }}
        run: |
          kubectl set image -n ${{ inputs.kube_namespace }} \
            deployment/${{ inputs.kube_deployment }} \
            ${{ inputs.kube_container }}=${{ inputs.image_name }}:${{ steps.version.outputs.version }}
