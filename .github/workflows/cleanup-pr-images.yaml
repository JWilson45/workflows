name: Cleanup GHCR PR Images

on:
  workflow_dispatch:
    inputs:
      image_name:
        description: "Image(s), comma-separated (blank = ghcr.io/JWilson45/<repo>)"
        required: false
        default: ""
        type: string
      pr_numbers:
        description: "PRs (e.g. 123,456). Blank = all"
        required: false
        default: ""
        type: string
      older_than_days:
        description: "Delete versions older than N days"
        required: true
        default: 7
        type: number

permissions:
  contents: read
  packages: write

jobs:
  plan:
    runs-on: workflows-runner-set
    permissions:
      contents: read
      packages: write
    outputs:
      candidate_count: ${{ steps.plan.outputs.candidate_count }}
    steps:
      - name: Build delete plan (dry run)
        id: plan
        uses: actions/github-script@v7
        env:
          IMAGE_NAME: ${{ inputs.image_name }}
          PR_NUMBERS: ${{ inputs.pr_numbers }}
          OLDER_THAN_DAYS: ${{ inputs.older_than_days }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const imageNameInput = String(process.env.IMAGE_NAME || "").trim();
            const prNumbersInput = String(process.env.PR_NUMBERS || "").trim();
            const olderThanDaysInput = String(process.env.OLDER_THAN_DAYS || "7").trim();

            if (!/^\d+$/.test(olderThanDaysInput)) {
              throw new Error(`older_than_days must be a non-negative integer. Received: ${olderThanDaysInput}`);
            }
            const olderThanDays = Number.parseInt(olderThanDaysInput, 10);
            const cutoffMs = Date.now() - olderThanDays * 24 * 60 * 60 * 1000;
            const cutoffIso = new Date(cutoffMs).toISOString();

            const selectedPrs = new Set();
            if (prNumbersInput.length > 0) {
              for (const raw of prNumbersInput.split(",")) {
                const pr = raw.trim();
                if (!pr) {
                  continue;
                }
                if (!/^\d+$/.test(pr)) {
                  throw new Error(`Invalid PR number "${pr}". Use comma-separated integers, e.g. 123,456`);
                }
                selectedPrs.add(pr);
              }
              if (selectedPrs.size === 0) {
                throw new Error("pr_numbers was provided but no valid PR numbers were parsed.");
              }
            }

            const imageNames = [];
            if (!imageNameInput) {
              const repoName = String(context.repo.repo || "").trim();
              if (!repoName) {
                throw new Error("Could not resolve image_name. Provide image_name directly.");
              }
              imageNames.push(`ghcr.io/JWilson45/${repoName}`);
            } else {
              for (const raw of imageNameInput.split(",")) {
                const value = raw.trim();
                if (value) {
                  imageNames.push(value);
                }
              }
              if (imageNames.length === 0) {
                throw new Error("image_name was provided but no valid values were parsed.");
              }
            }

            const uniqueImageNames = [...new Set(imageNames)];
            const prTagPattern = /-pr(\d+)-[0-9a-f]{7,}$/i;
            const extractPrFromTag = (tag) => {
              const match = String(tag || "").match(prTagPattern);
              return match ? match[1] : null;
            };

            const results = [];
            const deletePlan = {
              generatedAt: new Date().toISOString(),
              olderThanDays,
              cutoffIso,
              selectedPrs: [...selectedPrs],
              images: [],
            };

            for (const imageName of uniqueImageNames) {
              try {
                if (!imageName.startsWith("ghcr.io/")) {
                  throw new Error(`image_name must start with ghcr.io/. Received: ${imageName}`);
                }

                const imagePath = imageName.replace(/^ghcr\.io\//, "");
                const firstSlash = imagePath.indexOf("/");
                if (firstSlash <= 0 || firstSlash === imagePath.length - 1) {
                  throw new Error(`image_name must look like ghcr.io/<owner>/<package>. Received: ${imageName}`);
                }

                const owner = imagePath.slice(0, firstSlash);
                let packageName = imagePath.slice(firstSlash + 1);
                if (packageName.includes("@")) {
                  packageName = packageName.split("@", 1)[0];
                }
                if (packageName.includes(":")) {
                  packageName = packageName.split(":", 1)[0];
                }

                const listVersionsForOrg = () =>
                  github.paginate(
                    github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg,
                    {
                      org: owner,
                      package_type: "container",
                      package_name: packageName,
                      per_page: 100,
                    }
                  );

                const listVersionsForUser = () =>
                  github.paginate(
                    github.rest.packages.getAllPackageVersionsForPackageOwnedByUser,
                    {
                      username: owner,
                      package_type: "container",
                      package_name: packageName,
                      per_page: 100,
                    }
                  );

                let ownerScope = "org";
                let versions = [];
                try {
                  versions = await listVersionsForOrg();
                } catch (error) {
                  if (error.status === 404 || error.status === 422) {
                    ownerScope = "user";
                    versions = await listVersionsForUser();
                  } else if (error.status === 403) {
                    throw new Error(
                      `Forbidden while listing GHCR package versions for ${owner}/${packageName}. ` +
                        `Ensure this repository has package admin access and GITHUB_TOKEN can manage package versions.`
                    );
                  } else {
                    throw error;
                  }
                }

                const candidates = [];
                const protectedMixedTags = [];
                const skippedBySelection = [];
                const skippedByAge = [];
                const skippedNoTimestamp = [];

                for (const version of versions) {
                  const tags = version?.metadata?.container?.tags || [];
                  if (!Array.isArray(tags) || tags.length === 0) {
                    continue;
                  }

                  const extractedPrs = tags.map((tag) => extractPrFromTag(tag));
                  const hasPrTag = extractedPrs.some(Boolean);
                  const allPrTags = extractedPrs.every(Boolean);
                  if (!hasPrTag) {
                    continue;
                  }

                  if (!allPrTags) {
                    protectedMixedTags.push({ id: version.id, tags });
                    continue;
                  }

                  const versionPrs = [...new Set(extractedPrs)];
                  const matchesSelection =
                    selectedPrs.size === 0
                      ? true
                      : versionPrs.every((pr) => selectedPrs.has(pr));

                  if (!matchesSelection) {
                    if (selectedPrs.size > 0 && versionPrs.some((pr) => selectedPrs.has(pr))) {
                      skippedBySelection.push({ id: version.id, tags, prs: versionPrs });
                    }
                    continue;
                  }

                  const timestamp = version?.updated_at || version?.created_at;
                  if (!timestamp) {
                    skippedNoTimestamp.push({ id: version.id, tags, prs: versionPrs });
                    continue;
                  }

                  const timestampMs = Date.parse(timestamp);
                  if (Number.isNaN(timestampMs)) {
                    skippedNoTimestamp.push({ id: version.id, tags, prs: versionPrs });
                    continue;
                  }

                  if (timestampMs >= cutoffMs) {
                    skippedByAge.push({ id: version.id, tags, prs: versionPrs, updatedAt: timestamp });
                    continue;
                  }

                  candidates.push({ id: version.id, tags, prs: versionPrs, updatedAt: timestamp });
                }

                for (const candidate of candidates) {
                  core.info(
                    `[dry-run] [${owner}/${packageName}] Would delete version ${candidate.id} (${candidate.tags.join(", ")}) ` +
                      `updated_at=${candidate.updatedAt}`
                  );
                }

                deletePlan.images.push({
                  image: `${owner}/${packageName}`,
                  owner,
                  packageName,
                  versions: candidates.map((candidate) => ({
                    id: candidate.id,
                    tags: candidate.tags,
                    updatedAt: candidate.updatedAt,
                  })),
                });

                results.push({
                  image: `${owner}/${packageName}`,
                  versionsScanned: versions.length,
                  candidates: candidates.length,
                  protectedMixed: protectedMixedTags.length,
                  skippedBySelection: skippedBySelection.length,
                  skippedByAge: skippedByAge.length,
                  skippedNoTimestamp: skippedNoTimestamp.length,
                  error: null,
                });
              } catch (error) {
                results.push({
                  image: imageName,
                  versionsScanned: 0,
                  candidates: 0,
                  protectedMixed: 0,
                  skippedBySelection: 0,
                  skippedByAge: 0,
                  skippedNoTimestamp: 0,
                  error: error.message,
                });
                core.warning(`[${imageName}] ${error.message}`);
              }
            }

            const selectedText =
              selectedPrs.size > 0 ? [...selectedPrs].sort((a, b) => Number(a) - Number(b)).join(", ") : "ALL";

            const candidateCount = deletePlan.images.reduce((sum, image) => sum + image.versions.length, 0);
            fs.writeFileSync("delete-plan.json", JSON.stringify(deletePlan, null, 2));
            core.setOutput("candidate_count", String(candidateCount));

            await core.summary
              .addHeading("GHCR PR image cleanup plan (stage 1)")
              .addRaw(`Images: \`${uniqueImageNames.join(", ")}\`\n`)
              .addRaw(`Mode: \`dry-run\`\n`)
              .addRaw(`Selection: \`${selectedText}\`\n`)
              .addRaw(`Older than days: \`${olderThanDays}\`\n`)
              .addRaw(`Cutoff (UTC): \`${cutoffIso}\`\n`)
              .addRaw(`Total candidates: \`${candidateCount}\`\n\n`);

            for (const result of results) {
              core.summary
                .addRaw(`### ${result.image}\n`)
                .addRaw(`Versions scanned: \`${result.versionsScanned}\`\n`)
                .addRaw(`Candidates: \`${result.candidates}\`\n`)
                .addRaw(`Protected (mixed PR/non-PR tags): \`${result.protectedMixed}\`\n`)
                .addRaw(`Skipped (partial selection overlap): \`${result.skippedBySelection}\`\n`)
                .addRaw(`Skipped (newer than cutoff): \`${result.skippedByAge}\`\n`)
                .addRaw(`Skipped (missing/invalid timestamp): \`${result.skippedNoTimestamp}\`\n`);
              if (result.error) {
                core.summary.addRaw(`Error: \`${result.error}\`\n`);
              }
              core.summary.addRaw(`\n`);
            }

            await core.summary.write();

            const imageErrors = results.filter((r) => Boolean(r.error));
            if (imageErrors.length > 0) {
              core.setFailed(`Failed to process ${imageErrors.length} image(s). Check logs/summary.`);
            }

      - name: Upload delete plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: delete-plan
          path: delete-plan.json
          if-no-files-found: error

  delete:
    needs: plan
    if: needs.plan.result == 'success' && needs.plan.outputs.candidate_count != '0'
    runs-on: workflows-runner-set
    environment: delete
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download delete plan artifact
        uses: actions/download-artifact@v4
        with:
          name: delete-plan
          path: .

      - name: Delete planned versions (stage 2)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const raw = fs.readFileSync("delete-plan.json", "utf8");
            const plan = JSON.parse(raw);
            const images = Array.isArray(plan.images) ? plan.images : [];

            const results = [];
            for (const imagePlan of images) {
              const owner = imagePlan.owner;
              const packageName = imagePlan.packageName;
              const versions = Array.isArray(imagePlan.versions) ? imagePlan.versions : [];

              let deleted = 0;
              const failed = [];
              for (const version of versions) {
                const scopes = ["org", "user"];
                let success = false;
                let lastError = null;

                for (const scope of scopes) {
                  try {
                    if (scope === "org") {
                      await github.rest.packages.deletePackageVersionForOrg({
                        org: owner,
                        package_type: "container",
                        package_name: packageName,
                        package_version_id: version.id,
                      });
                    } else {
                      await github.rest.packages.deletePackageVersionForUser({
                        username: owner,
                        package_type: "container",
                        package_name: packageName,
                        package_version_id: version.id,
                      });
                    }
                    success = true;
                    break;
                  } catch (error) {
                    lastError = error;
                    if (error.status !== 404 && error.status !== 422) {
                      break;
                    }
                  }
                }

                if (success) {
                  deleted += 1;
                  core.info(
                    `[${owner}/${packageName}] Deleted version ${version.id} (${(version.tags || []).join(", ")})`
                  );
                } else {
                  const message =
                    `Delete failed in both owner scopes (org/user). ` +
                    `Last status=${lastError?.status || "unknown"} message=${lastError?.message || "unknown"}`;
                  failed.push({ id: version.id, error: message });
                  core.warning(`[${owner}/${packageName}] Failed to delete version ${version.id}: ${message}`);
                }
              }

              results.push({
                image: `${owner}/${packageName}`,
                planned: versions.length,
                deleted,
                failed: failed.length,
              });
            }

            await core.summary
              .addHeading("GHCR PR image cleanup delete (stage 2)")
              .addRaw(`Planned at: \`${plan.generatedAt || "unknown"}\`\n`)
              .addRaw(`Cutoff (UTC): \`${plan.cutoffIso || "unknown"}\`\n\n`);

            for (const result of results) {
              core.summary
                .addRaw(`### ${result.image}\n`)
                .addRaw(`Planned: \`${result.planned}\`\n`)
                .addRaw(`Deleted: \`${result.deleted}\`\n`)
                .addRaw(`Failed: \`${result.failed}\`\n\n`);
            }

            await core.summary.write();

            const failedTotal = results.reduce((sum, row) => sum + row.failed, 0);
            if (failedTotal > 0) {
              core.setFailed(`Failed to delete ${failedTotal} package version(s). Check logs/summary.`);
            }
